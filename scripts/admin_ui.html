<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Admin Approvals</title>
    <style>
      :root {
        --bg: #f5f8fb;
        --panel: #fff;
        --text: #1f2937;
        --muted: #6b7280;
        --border: #d9e1ec;
        --ok: #166534;
        --danger: #991b1b;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        background: linear-gradient(180deg, #eff6ff, var(--bg));
        color: var(--text);
        font-family: 'IBM Plex Sans', 'Segoe UI', sans-serif;
      }

      .container {
        max-width: 900px;
        margin: 20px auto;
        padding: 16px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px;
      }

      .top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      h2 { margin: 0 0 12px; }

      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .tabs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 10px 0 14px;
      }

      .tab {
        border: 1px solid var(--border);
        background: white;
        border-radius: 999px;
        padding: 8px 12px;
        cursor: pointer;
        color: var(--muted);
      }

      .tab.active {
        color: var(--text);
        border-color: #93c5fd;
        box-shadow: 0 1px 0 rgba(37,99,235,0.08);
      }

      input, textarea {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
      }

      #token { min-width: 300px; }
      #spot-start, #spot-end { min-width: 220px; }

      button {
        border: 1px solid var(--border);
        background: white;
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
      }

      .item {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 10px;
        background: #fcfdff;
      }

      .meta { color: var(--muted); margin-top: 3px; font-size: 0.92rem; }
      .decision-row { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
      .approve { color: var(--ok); border-color: #86efac; }
      .decline { color: var(--danger); border-color: #fecaca; }
      .error { color: var(--danger); }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th, td {
        border-bottom: 1px solid var(--border);
        padding: 8px;
        text-align: left;
        vertical-align: top;
        font-size: 0.95rem;
      }

      th { color: var(--muted); font-weight: 600; }

      @media (max-width: 720px) {
        #token { min-width: 0; width: 100%; }
        #spot-start, #spot-end { min-width: 0; width: 100%; }
        .decision-row button { width: 100%; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="panel">
        <div class="top">
          <h2 id="view-title">Admin Dashboard</h2>
          <a href="/chat/ui">Back to Chat UI</a>
        </div>

        <div id="build-info" class="meta" style="margin-bottom:10px;">Build: loading...</div>

        <div class="controls">
          <input id="token" type="password" placeholder="Admin token (x-api-token)" />
          <button id="save-token" type="button">Save token</button>
          <button id="refresh" type="button">Refresh</button>
          <label style="display:flex;align-items:center;gap:6px;">
            <input id="auto-refresh" type="checkbox" checked />
            Auto-refresh
          </label>
        </div>

        <div class="tabs" id="tabs">
          <button class="tab active" data-view="pending" type="button">Pending</button>
          <button class="tab" data-view="decided" type="button">Decisions</button>
          <button class="tab" data-view="reservations" type="button">Reservations</button>
          <button class="tab" data-view="spots" type="button">Spot board</button>
        </div>

        <div class="controls" id="spot-controls" style="display:none;">
          <input id="spot-start" type="datetime-local" />
          <input id="spot-end" type="datetime-local" />
          <button id="spot-refresh" type="button">Refresh spots</button>
        </div>

        <div id="summary" class="meta">Loading...</div>
        <div id="content" style="margin-top:10px;">Loading...</div>
      </div>
    </div>

    <script>
      const TOKEN_KEY = 'parking-admin-token';
      const tokenInput = document.getElementById('token');
      const saveTokenButton = document.getElementById('save-token');
      const refreshButton = document.getElementById('refresh');
      const autoRefresh = document.getElementById('auto-refresh');
      const summary = document.getElementById('summary');
      const buildInfo = document.getElementById('build-info');
      const viewTitle = document.getElementById('view-title');
      const tabs = document.getElementById('tabs');
      const content = document.getElementById('content');
      const spotControls = document.getElementById('spot-controls');
      const spotStartInput = document.getElementById('spot-start');
      const spotEndInput = document.getElementById('spot-end');
      const spotRefreshButton = document.getElementById('spot-refresh');

      let currentView = 'pending';

      tokenInput.value = localStorage.getItem(TOKEN_KEY) || '';

      function authHeaders() {
        const token = localStorage.getItem(TOKEN_KEY) || '';
        return token ? { 'x-api-token': token } : {};
      }

      function hasToken() {
        return !!(localStorage.getItem(TOKEN_KEY) || '').trim();
      }

      function formatDate(value) {
        if (!value) return 'n/a';
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? value : date.toLocaleString();
      }

      async function readResponsePayload(response) {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.toLowerCase().includes('application/json')) {
          try {
            return await response.json();
          } catch (_error) {
            return { detail: 'Failed to parse JSON response.' };
          }
        }
        const text = await response.text();
        return { detail: text || 'Unexpected non-JSON response.' };
      }

      saveTokenButton.addEventListener('click', () => {
        localStorage.setItem(TOKEN_KEY, tokenInput.value.trim());
        refreshView();
      });

      refreshButton.addEventListener('click', () => refreshView());

      function setActiveTab(view) {
        currentView = view;
        for (const btn of tabs.querySelectorAll('button[data-view]')) {
          btn.classList.toggle('active', btn.dataset.view === view);
        }
        spotControls.style.display = view === 'spots' ? 'flex' : 'none';
        if (view === 'pending') viewTitle.textContent = 'Pending Approval Requests';
        if (view === 'decided') viewTitle.textContent = 'Decisions (Approved/Declined)';
        if (view === 'reservations') viewTitle.textContent = 'Confirmed Reservations';
        if (view === 'spots') viewTitle.textContent = 'Parking Spot Board';
      }

      tabs.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-view]');
        if (!button) return;
        setActiveTab(button.dataset.view);
        refreshView();
      });

      function defaultSpotWindow() {
        const now = new Date();
        now.setSeconds(0);
        now.setMilliseconds(0);
        const end = new Date(now.getTime() + 2 * 60 * 60 * 1000);
        const toLocal = (d) => {
          const pad = (n) => String(n).padStart(2, '0');
          return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
        };
        return { start: toLocal(now), end: toLocal(end) };
      }

      const windowDefaults = defaultSpotWindow();
      spotStartInput.value = windowDefaults.start;
      spotEndInput.value = windowDefaults.end;
      spotRefreshButton.addEventListener('click', () => refreshView());

      async function fetchPending() {
        const container = content;
        if (!hasToken()) {
          summary.className = 'meta';
          summary.textContent = 'Provide admin token to view pending requests.';
          container.textContent = '';
          return;
        }
        try {
          const response = await fetch('/admin/requests', {
            headers: authHeaders(),
          });

          if (response.status === 401) {
            summary.textContent = 'Unauthorized. Provide valid admin token.';
            summary.className = 'error';
            container.textContent = '';
            return;
          }

          summary.className = 'meta';
          const requests = await readResponsePayload(response);
          const pending = Array.isArray(requests) ? requests : [];
          summary.textContent = `Pending requests: ${pending.length}`;

          if (pending.length === 0) {
            container.textContent = 'No pending requests.';
            return;
          }

          container.textContent = '';
          for (const item of pending) {
            const payload = item.payload || {};
            const requestId = item.request_id || '';

            const el = document.createElement('div');
            el.className = 'item';

            const reqLine = document.createElement('div');
            const reqStrong = document.createElement('strong');
            reqStrong.textContent = 'Request:';
            reqLine.appendChild(reqStrong);
            reqLine.appendChild(document.createTextNode(` ${requestId}`));
            el.appendChild(reqLine);

            const created = document.createElement('div');
            created.className = 'meta';
            created.textContent = `Created: ${formatDate(item.created_at)}`;
            el.appendChild(created);

            const name = document.createElement('div');
            name.className = 'meta';
            name.textContent = `Name: ${(payload.name || '').trim()} ${(payload.surname || '').trim()}`.trim();
            el.appendChild(name);

            const car = document.createElement('div');
            car.className = 'meta';
            car.textContent = `Car: ${payload.car_number || ''}`;
            el.appendChild(car);

            const period = document.createElement('div');
            period.className = 'meta';
            period.textContent = `Period: ${payload.reservation_period || ''}`;
            el.appendChild(period);

            const textarea = document.createElement('textarea');
            textarea.id = `note-${requestId}`;
            textarea.rows = 2;
            textarea.style.width = '100%';
            textarea.style.marginTop = '8px';
            textarea.placeholder = 'Optional admin note';
            el.appendChild(textarea);

            const row = document.createElement('div');
            row.className = 'decision-row';

            const approveBtn = document.createElement('button');
            approveBtn.className = 'approve';
            approveBtn.dataset.id = requestId;
            approveBtn.dataset.approved = 'true';
            approveBtn.textContent = 'Approve';
            row.appendChild(approveBtn);

            const declineBtn = document.createElement('button');
            declineBtn.className = 'decline';
            declineBtn.dataset.id = requestId;
            declineBtn.dataset.approved = 'false';
            declineBtn.textContent = 'Decline';
            row.appendChild(declineBtn);

            el.appendChild(row);
            container.appendChild(el);
          }
        } catch (_error) {
          summary.className = 'error';
          summary.textContent = 'Failed to load pending requests.';
        }
      }

      async function fetchDecided() {
        if (!hasToken()) {
          summary.className = 'meta';
          summary.textContent = 'Provide admin token to view decisions.';
          content.textContent = '';
          return;
        }
        try {
          const response = await fetch('/admin/decided', { headers: authHeaders() });
          const data = await readResponsePayload(response);
          if (!response.ok) {
            summary.className = 'error';
            summary.textContent = `Failed to load decisions (${response.status}).`;
            content.textContent = '';
            return;
          }
          const items = Array.isArray(data) ? data : [];
          summary.className = 'meta';
          summary.textContent = `Decisions: ${items.length}`;

          if (items.length === 0) {
            content.textContent = 'No decided requests yet.';
            return;
          }

          const table = document.createElement('table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Request</th><th>Status</th><th>Guest</th><th>Period</th><th>Decided</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');

          for (const item of items) {
            const payload = item.payload || {};
            const decision = item.decision || {};
            const status = decision.approved === true ? 'APPROVED' : 'DECLINED';
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${(item.request_id || '').toString()}</td>
              <td>${status}</td>
              <td>${`${(payload.name||'').trim()} ${(payload.surname||'').trim()}`.trim()}</td>
              <td>${(payload.reservation_period || '').toString()}</td>
              <td>${formatDate(decision.decided_at)}</td>
            `;
            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          content.textContent = '';
          content.appendChild(table);
        } catch (_error) {
          summary.className = 'error';
          summary.textContent = 'Failed to load decisions.';
          content.textContent = '';
        }
      }

      async function fetchReservations() {
        if (!hasToken()) {
          summary.className = 'meta';
          summary.textContent = 'Provide admin token to view reservations.';
          content.textContent = '';
          return;
        }
        try {
          const response = await fetch('/admin/reservations?limit=200', { headers: authHeaders() });
          const data = await readResponsePayload(response);
          if (!response.ok) {
            summary.className = 'error';
            summary.textContent = `Failed to load reservations (${response.status}).`;
            content.textContent = '';
            return;
          }
          const items = Array.isArray(data) ? data : [];
          summary.className = 'meta';
          summary.textContent = `Confirmed reservations: ${items.length}`;

          if (items.length === 0) {
            content.textContent = 'No confirmed reservations yet.';
            return;
          }

          const table = document.createElement('table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Spot</th><th>Guest</th><th>Car</th><th>Period</th><th>Approved</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');

          for (const item of items) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${(item.spot_id || '-').toString()}</td>
              <td>${(item.name || '').toString()}</td>
              <td>${(item.car_number || '').toString()}</td>
              <td>${(item.reservation_period || '').toString()}</td>
              <td>${formatDate(item.approval_time)}</td>
            `;
            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          content.textContent = '';
          content.appendChild(table);
        } catch (_error) {
          summary.className = 'error';
          summary.textContent = 'Failed to load reservations.';
          content.textContent = '';
        }
      }

      async function fetchSpotBoard() {
        if (!hasToken()) {
          summary.className = 'meta';
          summary.textContent = 'Provide admin token to view spot board.';
          content.textContent = '';
          return;
        }
        const start = (spotStartInput.value || '').trim();
        const end = (spotEndInput.value || '').trim();

        try {
          const url = `/admin/parking/spots?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;
          const response = await fetch(url, { headers: authHeaders() });
          const data = await readResponsePayload(response);
          if (!response.ok) {
            summary.className = 'error';
            summary.textContent = `Failed to load spot board (${response.status}).`;
            content.textContent = '';
            return;
          }

          const total = Number(data?.total_spots || 0);
          const booked = Number(data?.booked_spots || 0);
          summary.className = 'meta';
          summary.textContent = `Window: ${formatDate(data?.start)} -> ${formatDate(data?.end)} | Spots booked: ${booked}/${total}`;

          const spots = Array.isArray(data?.spots) ? data.spots : [];
          const table = document.createElement('table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Spot</th><th>Status</th><th>Booked until</th><th>Reservations</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');

          for (const spot of spots) {
            const tr = document.createElement('tr');
            const reservations = Array.isArray(spot?.reservations) ? spot.reservations : [];
            const details = reservations.map((r) => {
              const guest = (r.name || '').toString();
              const car = (r.car_number || '').toString();
              const period = (r.reservation_period || '').toString();
              return `${guest} (${car}) ${period}`.trim();
            }).filter(Boolean);
            tr.innerHTML = `
              <td>${(spot.spot_id || '').toString()}</td>
              <td>${(spot.status || '').toString()}</td>
              <td>${formatDate(spot.booked_until)}</td>
              <td>${details.length ? details.join('<br/>') : '-'}</td>
            `;
            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          content.textContent = '';
          content.appendChild(table);
        } catch (_error) {
          summary.className = 'error';
          summary.textContent = 'Failed to load spot board.';
          content.textContent = '';
        }
      }

      async function sendDecision(requestId, approved) {
        const noteEl = document.getElementById(`note-${requestId}`);
        const noteText = noteEl ? noteEl.value.trim() : '';

        const response = await fetch('/admin/decision', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeaders() },
          body: JSON.stringify({
            request_id: requestId,
            approved,
            notes: noteText || (approved ? 'Approved via admin UI' : 'Declined via admin UI'),
          }),
        });

        if (!response.ok) {
          throw new Error('Decision request failed');
        }
      }

      document.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-id]');
        if (!button) return;

        const requestId = button.dataset.id;
        const approved = button.dataset.approved === 'true';

        try {
          await sendDecision(requestId, approved);
          await fetchPending();
        } catch (_error) {
          alert('Unable to submit decision. Verify token and retry.');
        }
      });

      fetch('/version')
        .then((resp) => resp.json())
        .then((data) => {
          const sha = (data?.git_sha || '').toString().slice(0, 12);
          const when = (data?.build_time || '').toString();
          const env = (data?.app_env || '').toString();
          const parts = [];
          if (sha) parts.push(`sha ${sha}`);
          if (when) parts.push(when);
          if (env) parts.push(env);
          buildInfo.textContent = parts.length ? `Build: ${parts.join(' | ')}` : 'Build: unknown';
        })
        .catch(() => {
          buildInfo.textContent = 'Build: unavailable';
        });

      setInterval(() => {
        if (autoRefresh.checked && hasToken() && currentView === 'pending') {
          fetchPending();
        }
      }, 3000);

      function refreshView() {
        if (currentView === 'pending') return fetchPending();
        if (currentView === 'decided') return fetchDecided();
        if (currentView === 'reservations') return fetchReservations();
        if (currentView === 'spots') return fetchSpotBoard();
      }

      setActiveTab('pending');
      refreshView();
    </script>
  </body>
</html>
