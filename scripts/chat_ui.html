<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parking Chatbot UI</title>
    <style>
      :root {
        --bg: #f4f6f8;
        --panel: #ffffff;
        --text: #1d2430;
        --muted: #5b6678;
        --accent: #0f766e;
        --accent-2: #0369a1;
        --danger: #b91c1c;
        --border: #d8dee8;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: 'IBM Plex Sans', 'Segoe UI', sans-serif;
        background: radial-gradient(circle at top right, #dbeafe, transparent 40%), var(--bg);
        color: var(--text);
      }

      .container {
        max-width: 900px;
        margin: 20px auto;
        padding: 16px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 8px 24px rgba(7, 12, 24, 0.06);
      }

      .top-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      h1 {
        margin: 0;
        font-size: 1.6rem;
      }

      a { color: var(--accent-2); }

      .status-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.85rem;
        background: #ecfeff;
        color: #0f766e;
        border: 1px solid #99f6e4;
      }

      .status-chip.pending { background: #fffbeb; color: #92400e; border-color: #fde68a; }
      .status-chip.approved { background: #ecfdf3; color: #166534; border-color: #86efac; }
      .status-chip.declined { background: #fef2f2; color: #991b1b; border-color: #fecaca; }

      .progress-wrap {
        margin: 10px 0 12px;
      }

      .progress-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.9rem;
        margin-bottom: 6px;
      }

      .progress-track {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: #e9eef5;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        transition: width 220ms ease;
      }

      .error-banner {
        display: none;
        margin-top: 10px;
        border: 1px solid #fecaca;
        background: #fef2f2;
        color: var(--danger);
        padding: 10px;
        border-radius: 10px;
      }

      .auth-panel {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 12px;
        background: #f9fbff;
      }

      .auth-status {
        color: var(--muted);
        margin-bottom: 8px;
      }

      #messages {
        border: 1px solid var(--border);
        border-radius: 10px;
        min-height: 280px;
        max-height: 420px;
        overflow-y: auto;
        padding: 12px;
        margin-bottom: 12px;
        background: #fbfcfe;
      }

      .msg {
        margin: 10px 0;
        line-height: 1.35;
      }

      .user { font-weight: 600; }
      .bot { color: #1e3a8a; white-space: pre-line; }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }

      .btn {
        border: 1px solid var(--border);
        background: #fff;
        color: var(--text);
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
      }

      .btn.danger {
        background: #fff;
        border-color: #fecaca;
        color: #991b1b;
      }

      form {
        display: flex;
        gap: 8px;
      }

      input {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }

      @media (max-width: 720px) {
        .top-row { flex-direction: column; align-items: flex-start; }
        form { flex-direction: column; }
        button, .btn { width: 100%; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="panel">
        <div class="top-row">
          <h1>Parking Chatbot</h1>
          <span id="status-chip" class="status-chip">Info mode</span>
        </div>

        <p><a href="/admin/ui">Open Admin Approval UI</a></p>

        <div class="auth-panel">
          <div id="auth-status" class="auth-status">Checking sign-in...</div>
          <div id="auth-actions" class="actions" style="margin-bottom:0;"></div>
        </div>

        <div class="progress-wrap">
          <div class="progress-meta">
            <span id="progress-text">Booking progress: 0/5</span>
            <span id="status-detail">Ask a question or start a booking.</span>
          </div>
          <div class="progress-track">
            <div id="progress-fill" class="progress-fill"></div>
          </div>
        </div>

        <div id="messages"></div>

        <div id="actions" class="actions"></div>

        <form id="chat-form">
          <input id="message" type="text" placeholder="Type your message" required />
          <button id="dictate-btn" class="btn" type="button" title="Dictate using your microphone">Dictate</button>
          <button class="btn primary" type="submit">Send</button>
        </form>

        <div id="error-banner" class="error-banner">
          <div id="error-text">Request failed.</div>
          <button id="retry-btn" class="btn" type="button" style="margin-top:8px;">Retry last message</button>
        </div>
      </div>
    </div>

    <script>
      const THREAD_ID_KEY = 'parking-chat-thread-id';
      const form = document.getElementById('chat-form');
      const input = document.getElementById('message');
      const messages = document.getElementById('messages');
      const actions = document.getElementById('actions');
      const statusChip = document.getElementById('status-chip');
      const progressFill = document.getElementById('progress-fill');
      const progressText = document.getElementById('progress-text');
      const statusDetail = document.getElementById('status-detail');
      const errorBanner = document.getElementById('error-banner');
      const errorText = document.getElementById('error-text');
      const retryBtn = document.getElementById('retry-btn');
      const authStatus = document.getElementById('auth-status');
      const authActions = document.getElementById('auth-actions');
      const dictateBtn = document.getElementById('dictate-btn');

      let lastMessageForRetry = null;
      let currentThreadStorageKey = THREAD_ID_KEY;
      let isDictating = false;
      let isTranscribing = false;
      let speechRecognition = null;
      let mediaRecorder = null;
      let mediaStream = null;
      let mediaChunks = [];
      let dictationMode = null; // server | browser
      let statusDetailBackup = null;

      async function isServerDictationEnabled() {
        try {
          const resp = await fetch('/speech/enabled');
          if (!resp.ok) return false;
          const data = await resp.json();
          return !!data?.enabled;
        } catch (_error) {
          return false;
        }
      }

      function initBrowserDictation() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return false;

        dictationMode = 'browser';
        speechRecognition = new SpeechRecognition();
        speechRecognition.continuous = false;
        speechRecognition.interimResults = false;
        speechRecognition.lang = navigator.language || 'en-US';

        speechRecognition.addEventListener('start', () => {
          isDictating = true;
          dictateBtn.textContent = 'Stop';
          dictateBtn.setAttribute('aria-pressed', 'true');
          statusDetailBackup = statusDetail.textContent;
          statusDetail.textContent = 'Listening...';
        });

        speechRecognition.addEventListener('end', () => {
          isDictating = false;
          dictateBtn.textContent = 'Dictate';
          dictateBtn.setAttribute('aria-pressed', 'false');
          if (statusDetailBackup !== null) {
            statusDetail.textContent = statusDetailBackup;
            statusDetailBackup = null;
          }
        });

        speechRecognition.addEventListener('result', (event) => {
          const result = event?.results?.[0]?.[0];
          const transcript = (result?.transcript || '').trim();
          if (!transcript) return;
          input.value = `${(input.value || '').trim()}${input.value.trim() ? ' ' : ''}${transcript}`.trim();
          input.focus();
        });

        speechRecognition.addEventListener('error', (event) => {
          const code = event?.error || 'unknown';
          showError(`Dictation error: ${code}. Check microphone permissions and retry.`);
        });

        dictateBtn.addEventListener('click', () => {
          hideError();
          if (!speechRecognition) return;
          try {
            if (isDictating) {
              speechRecognition.stop();
            } else {
              speechRecognition.start();
            }
          } catch (error) {
            showError(`Dictation error: ${error.message}`);
          }
        });
        return true;
      }

      function initServerDictation() {
        if (!navigator.mediaDevices?.getUserMedia || !window.MediaRecorder) {
          return false;
        }

        dictationMode = 'server';

        function stopTracks() {
          if (!mediaStream) return;
          try {
            mediaStream.getTracks().forEach((track) => track.stop());
          } catch (_error) {}
          mediaStream = null;
        }

        async function transcribeBlob(blob) {
          const formData = new FormData();
          formData.append('file', blob, 'dictation.webm');

          const resp = await fetch('/speech/transcribe', {
            method: 'POST',
            body: formData,
          });
          const data = await readResponsePayload(resp);
          if (!resp.ok) {
            const detail = data?.detail || 'Request failed';
            throw new Error(detail);
          }
          return (data?.text || '').trim();
        }

        dictateBtn.addEventListener('click', async () => {
          hideError();
          if (isTranscribing) return;

          if (mediaRecorder && mediaRecorder.state === 'recording') {
            try {
              mediaRecorder.stop();
            } catch (_error) {}
            return;
          }

          try {
            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          } catch (error) {
            showError(`Microphone permission denied: ${error.message}`);
            return;
          }

          mediaChunks = [];
          const preferredTypes = ['audio/webm;codecs=opus', 'audio/webm'];
          const mimeType = preferredTypes.find((t) => MediaRecorder.isTypeSupported(t)) || '';

          try {
            mediaRecorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : undefined);
          } catch (error) {
            stopTracks();
            showError(`Dictation error: ${error.message}`);
            return;
          }

          mediaRecorder.addEventListener('dataavailable', (event) => {
            if (event?.data?.size) mediaChunks.push(event.data);
          });

          mediaRecorder.addEventListener('start', () => {
            isDictating = true;
            dictateBtn.textContent = 'Stop';
            dictateBtn.setAttribute('aria-pressed', 'true');
            statusDetailBackup = statusDetail.textContent;
            statusDetail.textContent = 'Listening...';
          });

          mediaRecorder.addEventListener('stop', async () => {
            isDictating = false;
            isTranscribing = true;
            dictateBtn.textContent = 'Transcribing...';
            dictateBtn.setAttribute('aria-pressed', 'false');
            dictateBtn.disabled = true;
            statusDetail.textContent = 'Transcribing...';

            const blob = new Blob(mediaChunks, { type: mimeType || 'audio/webm' });
            stopTracks();

            try {
              const transcript = await transcribeBlob(blob);
              if (transcript) {
                input.value = `${(input.value || '').trim()}${input.value.trim() ? ' ' : ''}${transcript}`.trim();
                input.focus();
              }
            } catch (error) {
              showError(`Dictation error: ${error.message}`);
            } finally {
              isTranscribing = false;
              dictateBtn.disabled = false;
              dictateBtn.textContent = 'Dictate';
              if (statusDetailBackup !== null) {
                statusDetail.textContent = statusDetailBackup;
                statusDetailBackup = null;
              }
            }
          });

          try {
            mediaRecorder.start();
          } catch (error) {
            stopTracks();
            showError(`Dictation error: ${error.message}`);
          }
        });
        return true;
      }

      async function initDictation() {
        // Prefer server-side dictation (OpenAI transcription) when available.
        const canRecord = !!(navigator.mediaDevices?.getUserMedia && window.MediaRecorder);
        if (canRecord && await isServerDictationEnabled()) {
          if (initServerDictation()) return;
        }
        if (initBrowserDictation()) return;
        dictateBtn.style.display = 'none';
      }

      function generateThreadId() {
        return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      function getThreadId() {
        let threadId = localStorage.getItem(currentThreadStorageKey);
        if (!threadId) {
          threadId = generateThreadId();
          localStorage.setItem(currentThreadStorageKey, threadId);
        }
        return threadId;
      }

      function append(role, text) {
        const div = document.createElement('div');
        div.className = `msg ${role}`;
        div.textContent = `${role === 'user' ? 'You' : 'Bot'}: ${text}`;
        messages.appendChild(div);
        messages.scrollTop = messages.scrollHeight;
      }

      function setChip(mode, status, label) {
        const text = label || (mode === 'booking' ? (status || 'booking') : 'Info mode');
        statusChip.textContent = text;
        statusChip.classList.remove('pending', 'approved', 'declined');
        if (status === 'pending') statusChip.classList.add('pending');
        if (status === 'approved') statusChip.classList.add('approved');
        if (status === 'declined') statusChip.classList.add('declined');
      }

      function setProgress(progress, detailText) {
        const current = progress?.current_step || 0;
        const total = progress?.total_steps || 5;
        const percent = progress?.percent || 0;
        progressFill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
        progressText.textContent = `Booking progress: ${current}/${total}`;
        statusDetail.textContent = detailText || 'Ask a question or start a booking.';
      }

      function showError(msg) {
        errorText.textContent = msg;
        errorBanner.style.display = 'block';
      }

      function hideError() {
        errorBanner.style.display = 'none';
      }

      function addActionButton(label, message, type = '') {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `btn ${type}`.trim();
        button.textContent = label;
        button.addEventListener('click', () => sendMessage(message, false));
        actions.appendChild(button);
      }

      function renderActions(data) {
        actions.innerHTML = '';
        const action = data?.action_required;

        if (action === 'review_confirmation') {
          addActionButton('Confirm booking', 'confirm', 'primary');
          addActionButton('Edit name', 'edit name');
          addActionButton('Edit surname', 'edit surname');
          addActionButton('Edit car number', 'edit car_number');
          addActionButton('Edit period', 'edit reservation_period');
          addActionButton('Cancel booking', 'cancel booking', 'danger');
          return;
        }

        if (action === 'await_admin_decision') {
          addActionButton('Check status', 'status');
          addActionButton('Start new booking', 'I want to reserve a spot');
          return;
        }

        if (data?.mode === 'booking') {
          addActionButton('Cancel booking', 'cancel booking', 'danger');
        }
      }

      function renderAlternatives(data) {
        const list = Array.isArray(data?.alternatives) ? data.alternatives : [];
        if (list.length === 0) return;
        append('bot', `Suggested alternatives:\n- ${list.join('\n- ')}`);
      }

      async function readResponsePayload(response) {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.toLowerCase().includes('application/json')) {
          try {
            return await response.json();
          } catch (_error) {
            return { detail: 'Failed to parse JSON response.' };
          }
        }
        const text = await response.text();
        return { detail: text || 'Unexpected non-JSON response.' };
      }

      async function loadAuthState() {
        authActions.innerHTML = '';

        const [meResp, providersResp] = await Promise.all([
          fetch('/auth/me'),
          fetch('/auth/providers'),
        ]);
        const me = await readResponsePayload(meResp);
        const providers = await readResponsePayload(providersResp);
        const providerList = Array.isArray(providers?.providers) ? providers.providers : [];

        if (me?.authenticated) {
          const user = me.user || {};
          const who = user.name || user.email || user.id || 'user';
          currentThreadStorageKey = `${THREAD_ID_KEY}:${user.id || 'session'}`;
          authStatus.textContent = `Signed in as ${who} (${user.provider || 'session'})`;
          const logoutButton = document.createElement('button');
          logoutButton.type = 'button';
          logoutButton.className = 'btn';
          logoutButton.textContent = 'Logout';
          logoutButton.addEventListener('click', async () => {
            await fetch('/auth/logout', { method: 'POST' });
            localStorage.removeItem(currentThreadStorageKey);
            window.location.reload();
          });
          authActions.appendChild(logoutButton);
          return;
        }

        currentThreadStorageKey = THREAD_ID_KEY;

        if (providerList.length === 0) {
          authStatus.textContent = 'Guest mode (OAuth providers are not configured).';
          return;
        }

        authStatus.textContent = 'Sign in to keep separate conversation history per user:';
        for (const provider of providerList) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'btn';
          button.textContent = `Login with ${provider.name || provider.id}`;
          button.addEventListener('click', () => {
            window.location.href = `/auth/login/${provider.id}`;
          });
          authActions.appendChild(button);
        }
      }

      async function sendMessage(message, echoUser = true) {
        const text = (message || '').trim();
        if (!text) return;

        hideError();
        lastMessageForRetry = text;

        if (echoUser) append('user', text);

        try {
          const response = await fetch('/chat/message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text, thread_id: getThreadId() }),
          });

          const data = await readResponsePayload(response);
          if (!response.ok) {
            const detail = data?.detail || 'Request failed';
            append('bot', `Sorry, I could not process that right now. ${detail}`);
            showError(`Backend request failed (${response.status}). You can retry your last message.`);
            return;
          }

          if (data.thread_id) {
            localStorage.setItem(currentThreadStorageKey, data.thread_id);
          }

          append('bot', data.response || '(empty response)');
          renderAlternatives(data);
          setChip(data.mode, data.status, data?.progress?.status_label);
          setProgress(data.progress, data.status_detail);
          renderActions(data);
        } catch (error) {
          append('bot', 'Network issue while contacting server. Please retry.');
          showError(`Network error: ${error.message}`);
        }
      }

      retryBtn.addEventListener('click', () => {
        if (!lastMessageForRetry) return;
        sendMessage(lastMessageForRetry, false);
      });

      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        const message = input.value.trim();
        if (!message) return;
        input.value = '';
        await sendMessage(message, true);
      });

      append('bot', 'Hello! Ask for parking info or start a booking request.');
      setProgress(null, 'Ask a question or start a booking.');
      setChip('info', 'collecting', 'Info mode');
      initDictation().catch(() => {
        dictateBtn.style.display = 'none';
      });
      loadAuthState().catch(() => {
        authStatus.textContent = 'Auth status is currently unavailable.';
      });
    </script>
  </body>
</html>
