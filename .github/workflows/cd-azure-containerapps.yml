name: CD Azure Hybrid (UI + Durable)

on:
  workflow_dispatch:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read

concurrency:
  group: cd-azure-hybrid-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY_NAME: ${{ vars.AZURE_ACR_NAME }}
  RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}

jobs:
  deploy-containers:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - app_name: chatbot-parking-ui
            image_name: chatbot-parking-ui

    steps:
      - uses: actions/checkout@v4

      - name: Check Azure configuration
        id: check-azure
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
        run: |
          if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_TENANT_ID" ] || [ -z "$AZURE_SUBSCRIPTION_ID" ] || [ -z "$AZURE_ACR_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
            echo "Azure configuration incomplete. Skipping deployment."
            echo "has-azure=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "has-azure=true" >> $GITHUB_OUTPUT

      - name: Preflight â€“ verify required secrets/vars
        if: steps.check-azure.outputs.has-azure == 'true'
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AZURE_FUNCTIONAPP_NAME: ${{ vars.AZURE_FUNCTIONAPP_NAME }}
          ADMIN_UI_TOKEN: ${{ secrets.ADMIN_UI_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SESSION_SECRET_KEY: ${{ secrets.SESSION_SECRET_KEY }}
        run: |
          set -e
          missing=0
          for v in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID AZURE_ACR_NAME AZURE_RESOURCE_GROUP AZURE_FUNCTIONAPP_NAME ADMIN_UI_TOKEN OPENAI_API_KEY SESSION_SECRET_KEY; do
            if [ -z "${!v}" ]; then
              echo "::error::$v is not set." >&2
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Azure Login (OIDC)
        if: steps.check-azure.outputs.has-azure == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          audience: api://AzureADTokenExchange

      - name: Build and push image to ACR
        if: steps.check-azure.outputs.has-azure == 'true'
        run: |
          az acr build \
            --registry "$REGISTRY_NAME" \
            --image "${{ matrix.image_name }}:${{ github.sha }}" \
            --image "${{ matrix.image_name }}:latest" \
            .

      - name: Deploy container app revision
        if: steps.check-azure.outputs.has-azure == 'true'
        run: |
          retry() {
            local n=0
            local max=10
            while true; do
              if "$@"; then
                return 0
              fi
              n=$((n+1))
              if [ "$n" -ge "$max" ]; then
                echo "::error::Command failed after $n attempts: $*" >&2
                return 1
              fi
              echo "Retrying in 10s (attempt $n/$max): $*" >&2
              sleep 10
            done
          }

          FULL_IMAGE="${REGISTRY_NAME}.azurecr.io/${{ matrix.image_name }}:${{ github.sha }}"
          BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          FUNC_NAME="${{ vars.AZURE_FUNCTIONAPP_NAME }}"
          FUNC_KEY="$(az functionapp keys list -g "$RESOURCE_GROUP" -n "$FUNC_NAME" --query 'functionKeys.default' -o tsv)"
          if [ -z "$FUNC_KEY" ]; then
            echo "::error::Unable to retrieve function key for $FUNC_NAME" >&2
            exit 1
          fi

          retry az containerapp secret set \
            --resource-group "$RESOURCE_GROUP" \
            --name "${{ matrix.app_name }}" \
            --secrets durable-function-key="$FUNC_KEY" admin-ui-token="${{ secrets.ADMIN_UI_TOKEN }}" openai-api-key="${{ secrets.OPENAI_API_KEY }}" session-secret-key="${{ secrets.SESSION_SECRET_KEY }}"

          OAUTH_ENV_ARGS=""
          if [ -n "${{ secrets.OAUTH_GITHUB_CLIENT_ID }}" ] && [ -n "${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}" ]; then
            retry az containerapp secret set \
              --resource-group "$RESOURCE_GROUP" \
              --name "${{ matrix.app_name }}" \
              --secrets oauth-github-client-id="${{ secrets.OAUTH_GITHUB_CLIENT_ID }}" oauth-github-client-secret="${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}"
            OAUTH_ENV_ARGS="OAUTH_GITHUB_CLIENT_ID=secretref:oauth-github-client-id OAUTH_GITHUB_CLIENT_SECRET=secretref:oauth-github-client-secret"
          fi

          retry az containerapp update \
            --resource-group "$RESOURCE_GROUP" \
            --name "${{ matrix.app_name }}" \
            --image "$FULL_IMAGE" \
            --set-env-vars \
              APP_ENV=prod \
              ADMIN_UI_TOKEN=secretref:admin-ui-token \
              SESSION_SECRET_KEY=secretref:session-secret-key \
              SESSION_HTTPS_ONLY=true \
              COSMOS_USE_MANAGED_IDENTITY=true \
              DURABLE_BASE_URL="https://${FUNC_NAME}.azurewebsites.net" \
              DURABLE_FUNCTION_KEY=secretref:durable-function-key \
              LLM_PROVIDER=openai \
              EMBEDDINGS_PROVIDER=openai \
              OPENAI_API_KEY=secretref:openai-api-key \
              LLM_MODEL=gpt-4o-mini \
              EMBEDDINGS_MODEL=text-embedding-3-small \
              PARKING_DB_PATH=/tmp/parking.db \
              RESERVATIONS_FILE_PATH=/tmp/reservations.txt \
              MCP_RECORD_RESERVATIONS=true \
              MCP_SERVER_COMMAND=python \
              MCP_SERVER_ARGS='-m chatbot_parking.mcp_servers.reservations_stdio_server' \
              BUILD_SHA='${{ github.sha }}' \
              BUILD_TIME="$BUILD_TIME" \
              $OAUTH_ENV_ARGS

      - name: Smoke test deployed UI + booking flow
        if: steps.check-azure.outputs.has-azure == 'true'
        env:
          ADMIN_UI_TOKEN: ${{ secrets.ADMIN_UI_TOKEN }}
        run: |
          FQDN="$(az containerapp show --resource-group "$RESOURCE_GROUP" --name "${{ matrix.app_name }}" --query 'properties.configuration.ingress.fqdn' -o tsv)"
          BASE_URL="https://${FQDN}"

          # Wait for the new revision to become ready.
          for i in $(seq 1 60); do
            if curl -fsSL "${BASE_URL}/admin/health" >/dev/null; then
              break
            fi
            sleep 5
          done

          # Ensure we are hitting the newly deployed revision (version stamp must match git SHA).
          for i in $(seq 1 60); do
            SHA="$(curl -fsSL "${BASE_URL}/version" | jq -r '.git_sha // empty' || true)"
            if [ "$SHA" = "${{ github.sha }}" ]; then
              break
            fi
            sleep 5
          done

          if [ "$SHA" != "${{ github.sha }}" ]; then
            echo "::error::Version check failed. Expected git_sha=${{ github.sha }}, got git_sha=${SHA:-<empty>}" >&2
            curl -fsSL "${BASE_URL}/version" || true
            exit 1
          fi

          BASE_URL="$BASE_URL" ADMIN_TOKEN="$ADMIN_UI_TOKEN" ./scripts/smoke_test_cloud.sh

  deploy-durable:
    # Build the Function package on ubuntu-latest, but install deps inside the official
    # Azure Functions Python runtime image to avoid glibc / wheel ABI mismatches.
    runs-on: ubuntu-latest
    needs: deploy-containers
    steps:
      - uses: actions/checkout@v4

      - name: Check Durable config
        id: check-durable
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_FUNCTIONAPP_NAME: ${{ vars.AZURE_FUNCTIONAPP_NAME }}
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
        run: |
          if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_TENANT_ID" ] || [ -z "$AZURE_SUBSCRIPTION_ID" ] || [ -z "$AZURE_FUNCTIONAPP_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
            echo "Durable deployment config incomplete. Skipping function deployment."
            echo "has-durable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "has-durable=true" >> $GITHUB_OUTPUT

      - name: Azure Login (OIDC)
        if: steps.check-durable.outputs.has-durable == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          audience: api://AzureADTokenExchange

      - name: Validate Durable Function App exists
        if: steps.check-durable.outputs.has-durable == 'true'
        id: durable-exists
        env:
          AZURE_FUNCTIONAPP_NAME: ${{ vars.AZURE_FUNCTIONAPP_NAME }}
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
        run: |
          if az functionapp show --name "$AZURE_FUNCTIONAPP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::Function App '$AZURE_FUNCTIONAPP_NAME' was not found. Skipping durable deployment."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Prepare function package
        if: steps.check-durable.outputs.has-durable == 'true' && steps.durable-exists.outputs.exists == 'true'
        run: |
          rsync -a src/ infra/azure/durable_functions/src/
          rsync -a data/ infra/azure/durable_functions/data/

          # Pre-build Python deps into the conventional folder so the Function App doesn't rely on remote build.
          rm -rf infra/azure/durable_functions/.python_packages
          mkdir -p infra/azure/durable_functions/.python_packages/lib/site-packages

          docker run --rm \
            -v "${GITHUB_WORKSPACE}/infra/azure/durable_functions:/workspace" \
            -w /workspace \
            mcr.microsoft.com/azure-functions/python:4-python3.11 \
            bash -lc "python -m pip install -r requirements.txt --target .python_packages/lib/site-packages"

      - name: Deploy Durable Function App
        if: steps.check-durable.outputs.has-durable == 'true' && steps.durable-exists.outputs.exists == 'true'
        uses: Azure/functions-action@v1
        with:
          app-name: ${{ vars.AZURE_FUNCTIONAPP_NAME }}
          package: infra/azure/durable_functions

      - name: Smoke test durable booking starter
        if: steps.check-durable.outputs.has-durable == 'true' && steps.durable-exists.outputs.exists == 'true'
        env:
          AZURE_FUNCTIONAPP_NAME: ${{ vars.AZURE_FUNCTIONAPP_NAME }}
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
        run: |
          set -euo pipefail
          BASE_URL="https://${AZURE_FUNCTIONAPP_NAME}.azurewebsites.net"
          FUNC_KEY="$(az functionapp keys list -g "$AZURE_RESOURCE_GROUP" -n "$AZURE_FUNCTIONAPP_NAME" --query 'functionKeys.default' -o tsv)"
          if [ -z "$FUNC_KEY" ]; then
            echo "::error::Unable to retrieve function key for $AZURE_FUNCTIONAPP_NAME" >&2
            exit 1
          fi

          THREAD_ID="ci-smoke-${GITHUB_RUN_ID}-${RANDOM}"
          STARTER="$(curl -fsSL -X POST "${BASE_URL}/api/chat/start" \
            -H "x-functions-key: ${FUNC_KEY}" \
            -H 'Content-Type: application/json' \
            -d "{\"message\":\"I want to book\",\"thread_id\":\"${THREAD_ID}\"}")"
          STATUS_URL="$(echo "$STARTER" | jq -r '.statusQueryGetUri // empty')"
          if [ -z "$STATUS_URL" ]; then
            echo "::error::Durable starter did not return statusQueryGetUri: $STARTER" >&2
            exit 1
          fi

          # Poll up to ~60s (Functions can cold-start).
          for i in $(seq 1 30); do
            STATUS="$(curl -fsSL "$STATUS_URL")"
            RS="$(echo "$STATUS" | jq -r '.runtimeStatus')"

            if [ "$RS" = "Completed" ]; then
              MODE="$(echo "$STATUS" | jq -r '.output.mode // empty')"
              PENDING="$(echo "$STATUS" | jq -r '.output.pending_field // empty')"
              if [ "$MODE" != "booking" ] || [ "$PENDING" != "name" ]; then
                echo "::error::Unexpected Durable output: $STATUS" >&2
                exit 1
              fi
              exit 0
            fi

            if [ "$RS" = "Failed" ] || [ "$RS" = "Terminated" ] || [ "$RS" = "Canceled" ]; then
              echo "::error::Durable orchestration ended with $RS: $STATUS" >&2
              exit 1
            fi

            sleep 2
          done

          echo "::error::Timed out waiting for durable completion: $STATUS" >&2
          exit 1
